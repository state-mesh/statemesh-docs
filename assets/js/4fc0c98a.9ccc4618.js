"use strict";(self.webpackChunkstatemesh_docs=self.webpackChunkstatemesh_docs||[]).push([[7093],{4535:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"blockchain/evm-diff","title":"EVM & API differences","description":"While the StateMesh blockchain node is implemented on top of go-ethereum (or geth), it has small differences due to its DAG-based asynchronous leaderless consensus.","source":"@site/docs/blockchain/evm-diff.mdx","sourceDirName":"blockchain","slug":"/blockchain/evm-diff","permalink":"/blockchain/evm-diff","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"EVM & API differences"},"sidebar":"mySidebar","previous":{"title":"Introduction","permalink":"/blockchain/info"},"next":{"title":"Wallet","permalink":"/blockchain/wallet"}}');var l=s(4848),t=s(8453);const a={title:"EVM & API differences"},o=void 0,c={},r=[{value:"Differences",id:"differences",level:2},{value:"Solidity differences",id:"solidity-differences",level:2},{value:"JSON-RPC API differences",id:"json-rpc-api-differences",level:2},{value:"Pending blocks",id:"pending-blocks",level:3},{value:"Block Header fields",id:"block-header-fields",level:3},{value:"Unavailable namespaces",id:"unavailable-namespaces",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.p,{children:["While the StateMesh blockchain node is implemented on top of ",(0,l.jsx)(n.code,{children:"go-ethereum"})," (or ",(0,l.jsx)(n.code,{children:"geth"}),"), it has small differences due to its DAG-based asynchronous leaderless consensus."]}),"\n",(0,l.jsx)(n.p,{children:"In terms of programmability, the chain is similar to Ethereum. Both networks run the Ethereum Virtual Machine (EVM) to support smart contract functionality. This means that all programming languages, developer tooling and standards that target the EVM are relevant to StateMesh as well. Developers building on StateMesh can write smart  contracts in Solidity, using their tooling of choice and take advantage of smart contract standards that have already been developed for Ethereum."}),"\n",(0,l.jsx)(n.h2,{id:"differences",children:"Differences"}),"\n",(0,l.jsx)(n.p,{children:"The EVM in StateMesh works the same way as Ethereum with the following exceptions:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"10% of unspent gas gets spent as a disincentive to militate against excessive transaction gas limits"}),"\n",(0,l.jsx)(n.li,{children:"transactions in blocks aren't necessarily sorted by gas price. Even though transactions in each event and in the txpool are sorted by gas price, events are sorted by their topological ordering in the DAG. A new block includes transactions from multiple confirmed events in that topological order."}),"\n",(0,l.jsx)(n.li,{children:"the protocol uses an asynchronous BFT Proof-of-Stake for consensus. This allows blocks to be created in 1 second compared to ~12+ seconds on Ethereum. In addition, all blocks are finalized immediately, so there is no need to wait for more than 1 block confirmation to ensure that a transaction won't be reverted."}),"\n",(0,l.jsx)(n.li,{children:"retrieval of pending blocks is not supported, because StateMesh does not have this concept."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"solidity-differences",children:"Solidity differences"}),"\n",(0,l.jsx)(n.p,{children:"The following Solidity global variables behave differently:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"block.difficulty"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"block.gaslimit"})," is always ",(0,l.jsx)(n.code,{children:"0xFFFFFFFFFFFF"})," (infinite)"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"json-rpc-api-differences",children:"JSON-RPC API differences"}),"\n",(0,l.jsx)(n.h3,{id:"pending-blocks",children:"Pending blocks"}),"\n",(0,l.jsx)(n.p,{children:"Retrieval of pending blocks is not supported, because StateMesh does not have this concept."}),"\n",(0,l.jsx)(n.h3,{id:"block-header-fields",children:"Block Header fields"}),"\n",(0,l.jsx)(n.p,{children:"The following fields in the block header are different:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"nonce"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mixHash"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"sha3Uncles"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"mixHash"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"miner"})," field is an undefined address"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"difficulty"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"extraData"})," is always empty"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gasLimit"})," is always 0xFFFFFFFFFFFF (infinite)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"receiptsRoot"})," is always 0"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"timestampNano"})," is a new field and returns the block's consensus time in UnixNano"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"unavailable-namespaces",children:"Unavailable namespaces"}),"\n",(0,l.jsx)(n.p,{children:"The following namespaces are not available:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"shh"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"db"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"bzz"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(6540);const l={},t=i.createContext(l);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);