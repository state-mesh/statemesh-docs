"use strict";(self.webpackChunkstatemesh_docs=self.webpackChunkstatemesh_docs||[]).push([[7750],{8395:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"architecture/blockchain","title":"The StateMesh Blockchain","description":"The StateMesh blockchain is an L1 EVM chain that uses Fantom\'s Lachesis DAG-based consensus for fast finality and high throughput. The chain is secured by a network of validators that stake MESH tokens to participate in consensus.","source":"@site/docs/architecture/blockchain.md","sourceDirName":"architecture","slug":"/architecture/blockchain","permalink":"/architecture/blockchain","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"The StateMesh Blockchain"},"sidebar":"mySidebar","previous":{"title":"Global Architecture","permalink":"/architecture/global"},"next":{"title":"Time Towers","permalink":"/architecture/time-towers"}}');var i=s(4848),a=s(8453);const o={title:"The StateMesh Blockchain"},r=void 0,c={},h=[{value:"Native Currency",id:"native-currency",level:2},{value:"Consensus",id:"consensus",level:2},{value:"Epochs",id:"epochs",level:2},{value:"Finality",id:"finality",level:2},{value:"Transaction fees",id:"transaction-fees",level:2},{value:"Gas",id:"gas",level:3},{value:"Max gas fee",id:"max-gas-fee",level:3},{value:"Time Towers and VDFs",id:"time-towers-and-vdfs",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The StateMesh blockchain is an L1 EVM chain that uses Fantom's ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2108.01900",children:"Lachesis"})," DAG-based consensus for fast finality and high throughput. The chain is secured by a network of validators that stake MESH tokens to participate in consensus."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The chain is not meant to be a general-purpose blockchain, but rather a specialized chain that is optimized for the needs of the StateMesh network."})}),"\n",(0,i.jsx)(n.p,{children:"The chain is designed to be highly scalable and secure, with a focus on enabling fast and low-cost transactions. It is also designed to be highly interoperable, with support for cross-chain communication and integration with other blockchains, for fast stablecoin bridging and other use cases."}),"\n",(0,i.jsx)(n.p,{children:"It is however a fully EVM-compatible chain, which means that it can run any smart contract that is compatible with the Ethereum Virtual Machine (EVM). This makes it easy for developers to port existing Ethereum smart contracts to the StateMesh chain, and to build new smart contracts that are compatible with the existing Ethereum ecosystem."}),"\n",(0,i.jsx)(n.h2,{id:"native-currency",children:"Native Currency"}),"\n",(0,i.jsxs)(n.p,{children:["The native currency of StateMesh is ",(0,i.jsx)(n.code,{children:"MESH"})," and its subdivision is ",(0,i.jsx)(n.code,{children:"wei"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["1 MESH = 10",(0,i.jsx)("sup",{children:"18"})," wei"]})}),"\n",(0,i.jsx)(n.h2,{id:"consensus",children:"Consensus"}),"\n",(0,i.jsx)(n.p,{children:"The blockchain uses PoS to secure the network. Validator nodes are responsible for generating and validating blocks. In return they will receive block rewards and a percentage of transaction fees and subscription fees. Based on their performance and reputation, validator nodes are assigned a score. They are incentivized to act in accordance with the network because they are subject to penalization (slashing) if they behave maliciously."}),"\n",(0,i.jsx)(n.p,{children:"The consensus is based on the Lachesis open-source software library. Lachesis is designed to easily plug into any blockchain node written in Golang, or in any other language if provided with a wrapper. Basically, Lachesis process consensus messages from other nodes and guarantee that everyone processes the same commands in the same order. To do this, it uses a DAG aBFT consensus algorithm."}),"\n",(0,i.jsx)(n.p,{children:"Lachesis is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Asynchronous: Participants have the freedom to process commands at different times."}),"\n",(0,i.jsx)(n.li,{children:"Leaderless: No participant plays a 'special' role"}),"\n",(0,i.jsx)(n.li,{children:"Byzantine Fault-Tolerant: Supports one third of faulty nodes, including malicious behavior"}),"\n",(0,i.jsx)(n.li,{children:"Final: Lachesis's output can be used immediately, no need for block confirmations, etc."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Lachesis is a DAG-based aBFT consensus protocol with guaranteed finality. The Lachesis protocol is leaderless achieving complete asynchrony, no round robin and no proof-of-work. Every confirmed transaction is final, unless more than 1/3W of validators are Byzantine"}),"\n",(0,i.jsx)(n.p,{children:"Each Lachesis node stores a local acyclic directed graph (DAG) composed of event blocks, each of which contains transactions. In this wiki, the terms 'event' and 'event block' are sometimes used interchangebly. The DAG capturing the happens-before relationship between the events is used to calculate an exact final order of events (and hence transactions) independently on each node."}),"\n",(0,i.jsx)(n.p,{children:"Events are divided into confirmed and unconfirmed events. New events are unconfirmed, whilst usually events from past 2-3+ frames are all confirmed. For confirmed events, honest nodes can compute their exact order. Unconfirmed events can only be partially ordered."}),"\n",(0,i.jsx)(n.p,{children:"Consensus results into batches of confirmed events, where each batch of events is called a block. Blocks (or finalized blocks) forming the final chain are calculated from event blocks independently on each node. Unlike PoW, round-robin PoS, coinage PoS and sync BFT, nodes don't send blocks to each other. Only events are being synced between nodes. Validators of the network do not vote on a concrete state of the network, but instead they periodically exchange transactions and events they observe with peers."}),"\n",(0,i.jsx)(n.p,{children:"Unlike sync BFT (like pBFT), Lachesis do not use new events in current election, but instead they are used to vote for the events in 2-3+ previous virtual elections simultaneously. This leads to a smaller number of created consensus messages, as the same event is reused in different elections. Hence, Lachesis achieves a lower TTF and a smaller consensus overhead comparing to sync BFT."}),"\n",(0,i.jsxs)(n.p,{children:["You can read more about Lachesis in their ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2108.01900",children:"paper"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"epochs",children:"Epochs"}),"\n",(0,i.jsx)(n.p,{children:"The protocol is organized in Epochs comprised of a number of (finalized) blocks. Each epoch is sealed when one of the below conditions is satisfied:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a maximum threshold of gas power was spent"}),"\n",(0,i.jsx)(n.li,{children:"the epoch's duration is finished"}),"\n",(0,i.jsx)(n.li,{children:"at least one dishonest validator is confirmed in the current block"}),"\n",(0,i.jsx)(n.li,{children:"on-request"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The lowest possible epoch number is 1."}),"\n",(0,i.jsx)(n.h2,{id:"finality",children:"Finality"}),"\n",(0,i.jsxs)(n.p,{children:["The chain is designed to provide fast finality, with transactions being confirmed ~ ",(0,i.jsx)(n.code,{children:"1 second"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"transaction-fees",children:"Transaction fees"}),"\n",(0,i.jsxs)(n.p,{children:["Each transaction on the blockchain requires a transaction fee paid to the network in order to prevent spam attacks. The fee is paid in the chain's native token ",(0,i.jsx)(n.code,{children:"MESH"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"gas",children:"Gas"}),"\n",(0,i.jsx)(n.p,{children:"Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the blockchain. Since each transaction requires computational resources to execute, each transaction requires a fee. Gas refers to the fee required to execute a transaction on StateMesh, regardless of transaction success or failure."}),"\n",(0,i.jsxs)(n.p,{children:["Gas fees are paid in the chain's native currency, ",(0,i.jsx)(n.code,{children:"MESH"}),". Gas prices are denoted in ",(0,i.jsx)(n.code,{children:"gwei"}),", which itself is a denomination of ",(0,i.jsx)(n.code,{children:"MESH"}),":"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["1 gwei = 10",(0,i.jsx)("sup",{children:"-9"})," or 0.000000001 MESH"]})}),"\n",(0,i.jsx)(n.h3,{id:"max-gas-fee",children:"Max gas fee"}),"\n",(0,i.jsx)(n.p,{children:"To execute a transaction on the network, users can specify a maximum limit they are willing to pay for their transaction to be executed. If the provided max fee exceeds the actual transaction fee, the sender is refunded the difference between the max fee and the actual computed fee."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The max fee must exceed the sum of the base fee and the tip"})}),"\n",(0,i.jsx)(n.h2,{id:"time-towers-and-vdfs",children:"Time Towers and VDFs"}),"\n",(0,i.jsx)(n.p,{children:"The chain uses a system Time Tower contract and native precompiles for verifying VDF proofs. Node operators submit VDF proofs at regular intervals (e.g. every 10 minutes) to the Time Tower contract. Blockchain validators verify the proofs and earn reward in MESH tokens. The Time Tower contract is used to ensure that the chain remains secure and that the VDFs are being computed correctly."}),"\n",(0,i.jsxs)(n.p,{children:["A detailed explanation of the Time Tower and VDFs can be found in the ",(0,i.jsx)(n.a,{href:"/architecture/time-towers",children:"Time Towers"})," section."]})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);